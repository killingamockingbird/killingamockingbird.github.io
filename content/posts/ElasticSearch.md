## ElasticSearch

## 核心概念

- **文档（Document）**：ES 存储的基本单元，类似一条 JSON 数据
- **索引（Index）**：存储一类文档的集合，类似于数据库中的表。
- **字段（Field）**：文档中的每个键值对。
- **倒排索引**：ES 的底层结构，用于加速全文搜索。
- **分片（Shard）与副本（Replica）**：ES 支持分布式存储和查询，分片用于水平扩展。

### 底层逻辑

#### 索引

在介绍**倒排索引**之前，我们先来了解一下**正排索引**和**全文检索**。

##### 全文检索

###### 定义

全文检索是指系统**不是按精确关键词匹配，而是理解文本内容的语言特性**，实现模糊匹配、分词、排序、短语识别等操作的搜索方式。

###### 例子

你在淘宝搜索框输入「苹果手机」，结果可能包括：

- 标题是「iPhone 15」
- 描述含有「苹果新品」
- 同义词或错拼「pingguo」

###### 全文检索VS模糊匹配

全文检索：

​	分词后匹配多个词项。

​	关键词需要准确

​	技术：分词器、倒排索引、BM25打分

模糊匹配:

​	近似匹配：如拼写错误

​	技术:Levenshtein编辑距离算法

##### 

##### 正排索引

即顺序索引，按照文档ID存储文档的所有内容。

因此每次进行全文索引的时候需要对**每个文档**的**所有内容**进行扫描。

查询需要O(n)的时间复杂度，对文章扫描更加耗时，因此正排索引进行全文检索的效率尤其低下。

于是出现了倒排索引

##### 倒排索引

###### 概念

接下来我们详细介绍倒排索引

**我们需要根据文本的词来找到相应的文档**，自然而然的我们可以想到**预处理**的模式，设置一个**映射**结构，即由**词项**来映射**文本id**

###### 实例

假设有以下 3 篇文档：

| 文档ID | 内容      |
| ------ | --------- |
| 1      | 苹果 手机 |
| 2      | 苹果 平板 |
| 3      | 小米 手机 |

构建倒排索引后：

```ini
iniCopyEdit"苹果" => [1, 2]
"手机" => [1, 3]
"平板" => [2]
"小米" => [3]
```

###### 倒排索引的构建

 假设数据

文档集如下：

| 文档 ID | 文本内容                   |
| ------- | -------------------------- |
| 1       | "I love apple phone"       |
| 2       | "Apple releases new phone" |
| 3       | "I like banana"            |

1. 文本清洗和规范化（Normalization）

   统一格式，便于处理：

   - 全部小写：大写 → 小写
   - 去除标点：`,`、`.` 等去除
   - 去除停用词（如：is, the, a）
   - 可选：词干提取（stemming）或词形还原（lemmatization）

   处理结果

   | 文档 ID | 处理后文本                 |
   | ------- | -------------------------- |
   | 1       | `i love apple phone`       |
   | 2       | `apple releases new phone` |
   | 3       | `i like banana`            |

2. 分词（Tokenization）

   将文本拆成一个个词项（token）：

   | 文档 ID | Token List                      |
   | ------- | ------------------------------- |
   | 1       | `[i, love, apple, phone]`       |
   | 2       | `[apple, releases, new, phone]` |
   | 3       | `[i, like, banana]`             |

3. 记录词项在文档中的位置和频率（Posting）

   构建 Posting 结构，一般如下：

   ```
   goCopyEdittype Posting struct {
     DocID     int
     Positions []int  // 单词在文档中的位置
     Frequency int    // 出现次数
   }
   ```

   如 `"apple"`：

   - 出现在文档 1 的位置 3（从 0 开始）
   - 出现在文档 2 的位置 0

4. 构建倒排表（Inverted Index）

   将所有文档中出现的 token 按词项归类，记录在哪些文档中出现，并附带位置信息。

   构建出的倒排索引如下：

   ```ini
   iniCopyEdit"i"        => [ {DocID:1, Pos:[0]}, {DocID:3, Pos:[0]} ]
   "love"     => [ {DocID:1, Pos:[1]} ]
   "apple"    => [ {DocID:1, Pos:[2]}, {DocID:2, Pos:[0]} ]
   "phone"    => [ {DocID:1, Pos:[3]}, {DocID:2, Pos:[3]} ]
   "releases" => [ {DocID:2, Pos:[1]} ]
   "new"      => [ {DocID:2, Pos:[2]} ]
   "like"     => [ {DocID:3, Pos:[1]} ]
   "banana"   => [ {DocID:3, Pos:[2]} ]
   ```

   这就是完整的倒排索引。

5. 压缩与优化（Lucene/ES 实现细节）

   真实系统中，为了节省空间和提高查询效率，还会进行：

   | 技术名                         | 作用                                    |
   | ------------------------------ | --------------------------------------- |
   | **跳跃表（skip list）**        | 快速跳过不相关文档块，提升查找效率      |
   | **位图压缩（Roaring bitmap）** | 压缩大规模 DocID 集合，提高布尔查询速度 |
   | **前缀压缩（Front coding）**   | 压缩词典中相似词项（如 apple, apples）  |
   | **段合并（Segment Merge）**    | 多个小段合并减少碎片，提升读取性能      |

### 