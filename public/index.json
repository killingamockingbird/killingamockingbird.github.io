[{"content":"ETCD kratos源码分析理解 1type Option func(o *options) 2 3type options struct { 4\tctx context.Context 5\tnamespace string 6\tttl time.Duration 7\tmaxRetry int 8} 9// Context with registry context. 10func Context(ctx context.Context) Option { 11\treturn func(o *options) { o.ctx = ctx } 12} 13 14// Namespace with registry namespace. 15func Namespace(ns string) Option { 16\treturn func(o *options) { o.namespace = ns } 17} 18 19// RegisterTTL with register ttl. 20func RegisterTTL(ttl time.Duration) Option { 21\treturn func(o *options) { o.ttl = ttl } 22} 23 24func MaxRetry(num int) Option { 25\treturn func(o *options) { o.maxRetry = num } 26} 27// Registry is etcd registry. 28type Registry struct { 29\topts *options 30\tclient *clientv3.Client 31\tkv clientv3.KV 32\tlease clientv3.Lease 33\t/* 34\tctxMap is used to store the context cancel function of each service instance. 35\tWhen the service instance is deregistered, the corresponding context cancel function is called to stop the heartbeat. 36\t*/ 37\tctxMap map[string]*serviceCancel 38} 这是kratos框架源码里部分的配置和结构体：\noptions ctx，用context.ground作为默认的上下文，表示不会主动取消 namespace，命名空间，用来标识注册的微服务，如\u0026quot;pay\u0026quot;,\u0026ldquo;item\u0026quot;等 ttl，注册的服务默认过期时间 maxRetry，最大尝试次数 registy opts，就是上面配置的options client，etcd客户端 kv，使用clientv3.NewKV(client)创建的KV操作对象,用于etcd交互 ctxMap，一个map，存储context便于心跳管理。 1// New creates etcd registry 2func New(client *clientv3.Client, opts ...Option) (r *Registry) { 3\top := \u0026amp;options{ 4\tctx: context.Background(), 5\tnamespace: \u0026#34;/microservices\u0026#34;, 6\tttl: time.Second * 15, 7\tmaxRetry: 5, 8\t}//默认配置 9\tfor _, o := range opts { 10\to(op)//更新读入的地址 11\t} 12\treturn \u0026amp;Registry{ 13\topts: op, 14\tclient: client, 15\tkv: clientv3.NewKV(client), 16\tctxMap: make(map[string]*serviceCancel), 17\t} 18} New函数来配置一些基本的信息：\n","permalink":"http://localhost:1313/posts/etcd/","summary":"\u003ch1 id=\"etcd\"\u003eETCD\u003c/h1\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250512114939110\" loading=\"lazy\" src=\"image-20250512114939110.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"kratos源码分析理解\"\u003ekratos源码分析理解\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 1\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003etype\u003c/span\u003e \u003cspan class=\"nx\"\u003eOption\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eo\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eoptions\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 2\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 3\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003etype\u003c/span\u003e \u003cspan class=\"nx\"\u003eoptions\u003c/span\u003e \u003cspan class=\"kd\"\u003estruct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 4\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003ectx\u003c/span\u003e       \u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eContext\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 5\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003enamespace\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 6\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003ettl\u003c/span\u003e       \u003cspan class=\"nx\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eDuration\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 7\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003emaxRetry\u003c/span\u003e  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 8\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e 9\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// Context with registry context.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e10\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003eContext\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ectx\u003c/span\u003e \u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eContext\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003eOption\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e11\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eo\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eoptions\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003eo\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ectx\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ectx\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e12\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e13\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e14\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// Namespace with registry namespace.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e15\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003eNamespace\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ens\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003eOption\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e16\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eo\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eoptions\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003eo\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enamespace\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ens\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e17\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e18\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e19\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// RegisterTTL with register ttl.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e20\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003eRegisterTTL\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ettl\u003c/span\u003e \u003cspan class=\"nx\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eDuration\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003eOption\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e21\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eo\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eoptions\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003eo\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ettl\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ettl\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e22\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e23\u003c/span\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e24\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003eMaxRetry\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003enum\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003eOption\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e25\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eo\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eoptions\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003eo\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003emaxRetry\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003enum\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e26\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e27\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// Registry is etcd registry.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e28\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003etype\u003c/span\u003e \u003cspan class=\"nx\"\u003eRegistry\u003c/span\u003e \u003cspan class=\"kd\"\u003estruct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e29\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eopts\u003c/span\u003e   \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eoptions\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e30\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eclient\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eclientv3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eClient\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e31\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003ekv\u003c/span\u003e     \u003cspan class=\"nx\"\u003eclientv3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eKV\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e32\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003elease\u003c/span\u003e  \u003cspan class=\"nx\"\u003eclientv3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eLease\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e33\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e34\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\t\tctxMap is used to store the context cancel function of each service instance.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e35\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\t\tWhen the service instance is deregistered, the corresponding context cancel function is called to stop the heartbeat.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e36\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\t*/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e37\u003c/span\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003ectxMap\u003c/span\u003e \u003cspan class=\"kd\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eserviceCancel\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"ln\"\u003e38\u003c/span\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这是kratos框架源码里部分的配置和结构体：\u003c/p\u003e","title":"ETCD"},{"content":"初识微服务 引入 单体灾难 单体架构（Monolithic Architecture）虽然开发简单、部署方便，但随着系统规模变大弊端十分明显。\n功能模块耦合度高，代码难以维护 功能难以修改，牵一发而动全身 难以扩展，工程量大 救赎之道：微服务架构 微服务的定义 《The Art of Scalability》描述了一个三维可拓展模型\nX轴扩展（Horizontal Duplication） 复制系统，增加副本数量\n指的是横向复制应用程序实例（通常是无状态服务），比如部署多个服务器处理同样的流量。 典型方式：加机器，做负载均衡。 场景例子：多个 Web 服务器后面挂一台负载均衡器，流量随机分配到不同服务器。 关键词：副本、无状态、多实例、负载均衡\nY轴扩展（Functional Decomposition） 按功能模块拆分系统\n把不同业务功能拆成独立服务或模块，每个模块单独部署和扩展。 典型方式：前端、订单、支付、库存各自是独立服务。 场景例子：外卖系统把“用户模块”、“商品模块”、“订单模块”拆成不同微服务。 关键词：模块拆分、微服务、领域划分\nZ轴扩展（Data Partitioning） 按数据范围拆分系统\n将同一个功能模块的数据按某种规则划分，不同的数据分配到不同的服务器。 典型方式：按用户 ID 取模（hash）划分，或者按地理区域划分。 场景例子：AM字母开头的用户在一批数据库，NZ字母开头的用户在另一批。 关键词：分区、分表、分库、Sharding（分片）\n微服务架构：把程序功能性分解为一组服务\n微服务架构的好处 简单来讲，微服务可以\n模块独立，开发快 每个服务只做一件事，团队可以独立开发、独立上线，互不影响。 扩展灵活，节省资源 哪个服务压力大，就单独扩容，不用整体扩机器，更省钱。 故障隔离，系统更稳 一个服务出问题，只影响它自己，不会拖垮整个系统。 技术栈自由 每个服务可以用最适合自己的技术，比如一个用 Go 写高并发，一个用 Python 写数据处理。 部署升级快 小服务改动小，上线快，回滚也方便，支持敏捷开发。 ","permalink":"http://localhost:1313/posts/2025-04-27-introduction-to-microservice/","summary":"\u003ch1 id=\"初识微服务\"\u003e初识微服务\u003c/h1\u003e\n\u003ch2 id=\"引入\"\u003e引入\u003c/h2\u003e\n\u003ch3 id=\"单体灾难\"\u003e单体灾难\u003c/h3\u003e\n\u003cp\u003e单体架构（Monolithic Architecture）虽然开发简单、部署方便，但随着系统规模变大弊端十分明显。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e功能模块耦合度高，代码难以维护\u003c/li\u003e\n\u003cli\u003e功能难以修改，牵一发而动全身\u003c/li\u003e\n\u003cli\u003e难以扩展，工程量大\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"救赎之道微服务架构\"\u003e救赎之道：微服务架构\u003c/h3\u003e\n\u003ch4 id=\"微服务的定义\"\u003e微服务的定义\u003c/h4\u003e\n\u003cp\u003e《The Art of Scalability》描述了一个三维可拓展模型\u003c/p\u003e","title":"Introduction to Microservice"},{"content":"","permalink":"http://localhost:1313/posts/test/","summary":"","title":"test"},{"content":"Kubernetes ","permalink":"http://localhost:1313/posts/kubernetes/kubernetes/","summary":"\u003ch1 id=\"kubernetes\"\u003eKubernetes\u003c/h1\u003e\n\u003ch2\u003e\u003c/h2\u003e","title":"Kubernetes"},{"content":"B tree and B+ tree B tree 引入 B 树（B-tree）是一种自平衡的搜索树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B 树的每个节点可以拥有两个以上的子节点，因此 B 树是一种多路搜索树。\n在 B 树中，有两种节点：\n内部节点（internal node）：存储了数据以及指向其子节点的指针。 叶子节点（leaf node）：与内部节点不同的是，叶子节点只存储数据，并没有子节点。 性质 B树的定义 B树是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数 M ，阶数 M 代表一个树节点最多有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉。\n一棵M阶B树，有如下特性：\n若根节点不是叶子结点，则至少有两棵树。 每一个节点最多M棵子树，最多有M-1个关键字（键值对）。 除根节点外，其他的每个分支至少有ceil(M/2)个子树，至少含有ceil(M/2)-1个关键字。 每个节点中的关键字都按照大小顺序排列，每个关键字的左子树的所有关键字都小于它，每个关键字的右子树都大于它。 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 一个简单的 5 阶 B 树的图例如下：\n![B树](3-29 B Tree.assets/btree_demo.png)\n过程 与 二叉搜索树 类似，B 树的基本操作有查找，遍历，插入，删除。\n以下的描述中，用「元素」一词指代节点内部所保存的数据。在其它的数据结构教程中，可能也会使用「关键字」、「键」、「关键码」等表述，它们的含义都相同。\n查找 B 树中的节点包含有多个元素。假设需要查找的是 ，那么从根节点开始，从上到下递归的遍历树。在每一层上，搜索的范围被减小到包含了搜索值的子树中。子树值的范围被它的父节点的元素确定。因为是从根节点开始的二分法查找，所以查找一个元素的代码如下：\n1func (n *BTreeNode) Search(k int) bool { 2\ti := sort.SearchInts(n.keys, k) 3\tif i \u0026lt; len(n.keys) \u0026amp;\u0026amp; n.keys[i] == k { 4\treturn true 5\t} 6\tif !n.leaf { 7\treturn n.children[i].Search(k) 8\t} 9\treturn false 10} 插入 针对m阶高度h的B树，插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素。\n若该节点元素个数小于m-1，直接插入； 若该节点元素个数等于m-1，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中； 重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1； 1应该先Search一下节点是否存在的 2 3// 插入操作 4func (t *BTree) Insert(k int) bool{ 5\troot := t.root 6 if root.Search {//k已存在 7 return false 8 } 9\tif len(root.keys) == 2*t.t-1 {//根节点上溢出 10\tnewRoot := NewBTreeNode(false)//建一个根节点（父节点） 11\tnewRoot.children = append(newRoot.children, root) 12\tt.splitChild(newRoot, 0)//就一个孩子 index=0 13\tt.root = newRoot 14\t} 15\tt.insertNonFull(t.root, k) 16 return true 17} 18 19func (t *BTree) NewInsertNonFull(n *BTreeNode, k int) {//只会在叶子层插入 20 if n.leaf {//叶子层 21\ti := sort.SearchInts(n.keys, k)//找k的位置 22 //i后面的数据右移1，插入k 23\tn.keys = append(n.keys, 0) 24\tcopy(n.keys[i+1:], n.keys[i:]) 25\tn.keys[i] = k 26\t} else {//内部节点层 27\ti := sort.SearchInts(n.keys, k) 28\tif len(n.children[i].keys) == 2*t.t-1 {//有可能会上溢出，直接分裂 29\tt.splitChild(n, i) 30\tif k \u0026gt; n.keys[i] {//分裂向上提了一个节点和k比较 31\ti++ 32\t} 33\t} 34\tt.NewInsertNonFull(n.children[i], k)//继续向叶子层走 35\t} 36} 37 38 39// 节点分裂 40func (t *BTree) splitChild(parent *BTreeNode, index int) { 41\tchild := parent.children[index]//分裂后左子树 42\tnewChild := NewBTreeNode(child.leaf)//分裂后右子树 43 44\t// 分裂keys 45 mid := len(child.keys)//从中间分裂 46 //下层key提取到parent 47\tparent.keys = append(parent.keys, 0) 48\tcopy(parent.keys[index+1:], parent.keys[index:]) 49\tparent.keys[index] = child.keys[mid] 50 51\t// 处理子节点 52 newChild.keys = append(newChild.keys, child.keys[mid+1:]...)//右子树keys为[mid+1:] 53 child.keys = child.keys[:mid] //左子树[:mid] 54 55\tif !child.leaf {//非叶子节点需要迁移子树，以mid为界左边给child 右边给newChild 56\tnewChild.children = append(newChild.children, child.children[mid+1:]...) 57\tchild.children = child.children[:mid+1] 58\t} 59\t//更新上层children（多个一个子节点）原指向节点（已修改）可以直接指向，只需加右节点即可 60\tparent.children = append(parent.children, nil) 61\tcopy(parent.children[index+2:], parent.children[index+1:]) 62\tparent.children[index+1] = newChild 63} 构建 重复插入操作\n删除 首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除；删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除。\n某结点中元素数目小于（m/2）-1,(m/2)向上取整，则需要看其某相邻兄弟结点是否丰满； 如果丰满（结点中元素个数大于(m/2)-1），则向父节点借一个元素来满足条件； 如果其相邻兄弟都不丰满，即其结点数目等于(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点； 接下来还以5阶B树为例，详细讲解删除的动作；\n关键要领，元素个数小于 2（m/2 -1）就合并，大于4（m-1）就分裂\n如图依次删除依次删除【8】,【20】,【18】,【5】\n首先删除元素【8】，当然首先查找【8】，【8】在一个叶子结点中，删除后该叶子结点元素个数为2，符合B树规则，操作很简单，咱们只需要移动【11】至原来【8】的位置，移动【12】至【11】的位置（也就是结点中删除元素后面的元素向前移动）\n下一步，删除【20】,因为【20】没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者【23】(字母升序的下个元素即直接后驱节点)（会在直接前驱和后驱后驱节点中选元素足够的），将【23】上移到【20】的位置，然后将孩子结点中的【23】进行删除，这里恰好删除后，该孩子结点中元素个数大于2，无需进行合并操作。\n下一步删除【18】，【18】在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目2,而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中，在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素【23】下移到该叶子结点中，代替原来【19】的位置，【19】前移；然【24】在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除【24】，后面元素前移。\n最后一步删除【5】， 删除后会导致很多问题，因为【5】所在的结点数目刚好达标，刚好满足最小元素个数ceil(5/2)-1=2,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素【4】下移到已经删除【5】而只有【6】的结点中，然后将含有【4】和【6】的结点和含有【1】,【3】的相邻兄弟结点进行合并成一个结点。\n也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素【7】，没达标（因为非根节点包括叶子结点的元素K必须满足于2=\u0026lt;K\u0026lt;=4，而此处的K=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。而此时兄弟节点元素刚好为2，刚刚满足，只能进行合并，而根结点中的唯一元素【13】下移到子结点，这样，树的高度减少一层。\n代码：\n1 2// 删除操作入口 3func (t *BTree) Delete(k int) { 4\tt.deleteFromNode(t.root, k) 5\t// 处理根节点键空的情况 6\t//Case 4:根节点下溢出，直接释放根节点即可 7\tif len(t.root.keys) == 0 \u0026amp;\u0026amp; !t.root.leaf { 8\tt.root = t.root.children[0] 9\t} 10} 11 12// 递归删除主逻辑 13func (t *BTree) deleteFromNode(n *BTreeNode, k int) { 14\ti := sort.SearchInts(n.keys, k) 15 16\t// Case 1: 键在当前节点 17\tif i \u0026lt; len(n.keys) \u0026amp;\u0026amp; n.keys[i] == k { 18\tif n.leaf { 19\t// Case 1a: 直接从叶子删除 20\tn.keys = append(n.keys[:i], n.keys[i+1:]...) 21\t} else { 22\t// Case 1b: 内部节点删除 23\tt.deleteInternal(n, i) 24\t} 25\t} else { 26\t// Case 2: 键不在当前节点 27\tif n.leaf { 28\treturn // 键不存在 29\t} 30\t// 确定子节点路径 31\tend := len(n.keys) 32\tif i == end { 33\ti-- // 防止越界 34\t} 35\tchild := n.children[i] 36\t// Case 3: 确保子节点有足够的元素 37\tif len(child.keys) \u0026lt; t.t { 38\tt.fillChild(n, i) 39\t} 40\t// 递归删除 41\tt.deleteFromNode(child, k) 42\t} 43} 44 45// 处理内部节点删除 46// 所有内部节点的删除都转化为叶子节点的删除 47func (t *BTree) deleteInternal(n *BTreeNode, i int) { 48\tk := n.keys[i] 49 50\t// Case 1b1: 左子节点有足够的元素 51\tleftChild := n.children[i] 52\tif len(leftChild.keys) \u0026gt;= t.t { 53\tpred := t.getPredecessor(leftChild) 54\tn.keys[i] = pred 55\tt.deleteFromNode(leftChild, pred) 56\treturn 57\t} 58 59\t// Case 1b2: 右子节点有足够的元素 60\trightChild := n.children[i+1] 61\tif len(rightChild.keys) \u0026gt;= t.t { 62\tsucc := t.getSuccessor(rightChild) 63\tn.keys[i] = succ 64\tt.deleteFromNode(rightChild, succ) 65\treturn 66\t} 67\t//有可能下溢出就直接合并 68\t// Case 1b3: 合并左右子节点 69\tt.mergeChildren(n, i) 70\tt.deleteFromNode(leftChild, k) //合并到了左子树 71} 72 73// 获取前驱键 74func (t *BTree) getPredecessor(n *BTreeNode) int { 75\tfor !n.leaf { 76\tn = n.children[len(n.children)-1] 77\t} 78\treturn n.keys[len(n.keys)-1] 79} 80 81// 获取后继键 82func (t *BTree) getSuccessor(n *BTreeNode) int { 83\tfor !n.leaf { 84\tn = n.children[0] 85\t} 86\treturn n.keys[0] 87} 88 89// 补充子节点键数不足 90func (t *BTree) fillChild(parent *BTreeNode, i int) { 91\tchild := parent.children[i] 92 93\t// Case 3a: 向左兄弟借键 94\tif i \u0026gt; 0 { 95\tleftSib := parent.children[i-1] //左兄弟 96\tif len(leftSib.keys) \u0026gt;= t.t { 97\t// 父节点下移键 98\tchild.keys = append([]int{parent.keys[i-1]}, child.keys...) //加到最前面 99\tparent.keys[i-1] = leftSib.keys[len(leftSib.keys)-1] //左子树最后元素上移 100\t// 转移子节点指针 101\tif !leftSib.leaf { //非叶节点要将子树转移到child（最前面） 102\tchild.children = append([]*BTreeNode{leftSib.children[len(leftSib.children)-1]}, child.children...) 103\tleftSib.children = leftSib.children[:len(leftSib.children)-1] //转移后删去子树 104\t} 105\tleftSib.keys = leftSib.keys[:len(leftSib.keys)-1] 106\treturn 107\t} 108\t} 109 110\t// Case 3b: 向右兄弟借键 111\tif i \u0026lt; len(parent.children)-1 { 112\trightSib := parent.children[i+1] 113\tif len(rightSib.keys) \u0026gt;= t.t { 114\t// 父节点下移键 115\tchild.keys = append(child.keys, parent.keys[i]) 116\tparent.keys[i] = rightSib.keys[0] 117\t// 转移子节点指针 118\tif !rightSib.leaf { 119\tchild.children = append(child.children, rightSib.children[0]) 120\trightSib.children = rightSib.children[1:] 121\t} 122\trightSib.keys = rightSib.keys[1:] 123\treturn 124\t} 125\t} 126 127\t// Case 3c: 合并操作 128\tif i \u0026gt; 0 { 129\tt.mergeChildren(parent, i-1) 130\t} else { 131\tt.mergeChildren(parent, i) 132\t} 133} 134 135// 合并相邻子节点 136func (t *BTree) mergeChildren(parent *BTreeNode, i int) { 137\t//将右子树与左子树合并到左子树中 138\tleft := parent.children[i] 139\tright := parent.children[i+1] 140 141\t// 合并键 142\tleft.keys = append(left.keys, parent.keys[i]) //父节点下移 143\tleft.keys = append(left.keys, right.keys...) //合并 144 145\t// 合并子节点指针 146\tif !left.leaf { //非叶节点子树迁移 147\tleft.children = append(left.children, right.children...) 148\t} 149 150\t// 调整父节点 151\tparent.keys = append(parent.keys[:i], parent.keys[i+1:]...) //删除父节点 152\tparent.children = append(parent.children[:i+1], parent.children[i+2:]...) //删除子树 153} B+ tree 引入 B+树是一种数据结构，是一个N叉排序树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点， 也可能是一个包含两个或两个以上孩子节点的节点。\nB+树通常用于数据库和操作系统的文件系统中。NTFS、ReiserFS、NSS、XFS、JFS、ReFS和BFS等文件系统都在使用B+树作为元数据索引。B+树的特点是能够保持数据稳定有序， 其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入。\n性质 B+树的定义 B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于：\n1) 有n棵子树的节点中含有n个关键字(即每个关键字对应一棵子树)；\n2) 所有叶子节点中包含了全部关键字的信息， 及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接；\n3) 所有的非终端节点可以看成是索引部分，节点中仅含有其子树（根节点）中的最大（或最小)关键字\n4) 除根节点外，其他所有节点中所含关键字的个数必须\u0026gt;=⌈m/2⌉(注意： B-树是除根以外的所有非终端节点至少有⌈m/2⌉棵子树)\n下图是所示为一棵3阶的B+树，通常在B+树上有两个指针头， 一个指向根节点，另一个指向关键字最小的叶子节点。因此，可以对B+树进行两种查找运算： 一种是从最小关键字起顺序查找，另一种是从根节点开始，进行随机查找。\n特性 所有关键字都出现在叶子节点的链表中（稠密索引），且链表中的关键字恰好是有序的； 不可能在非叶子节点命中； 非叶子节点相当于叶子节点的索引（稀疏索引），叶子节点相当于是存储（关键字）数据的数据层； 更适合文件索引系统； ![ds-bplus-tree2](3-29 B Tree.assets/ds_bplus_tree2.jpg)\nB tree，B+ tree，二分查找树，自平衡二叉树 什么是二分查找树？ 二叉树 左子树的所有结点小于该节点 右子树的所有节点大于该节点 问题：\n极端情况下二分查找树会退化为链表（插入的元素一直递增就会出现这种情况）\n不能范围查询\n随着元素的加入，树高会快速增加\n自平衡二叉树 为了解决二分查找树退化成链表的问题，有人提出AVL树\nAVL树在二分查找树的基础上加了一个约束：\n左子树和右子树的高度差不能超过1\nPS:感兴趣的也可以去了解一下红黑树\n另外的两个问题没有解决\n于是就出现了B树和B+树\nB树和B+树性能上的区别 单点查询\nB树最快情况下可以O(1)查询到数据，平均来看B树会比B+树快一些\n但是区别不是很大\n插入和删除效率\nB+树有大量冗余的节点（也是一种弊端），删除时可以直接删除不怎么需要懂内部节点\nB树就不一样了，插入删除操作已经讲过，对树结构的影响比较大\n范围查询\nMYSQL中的B+树 MySOL的存储方式根据存储引擎的不同而不同，我们最常用的就是Innodb 存储引擎，它就是采用了B+树作为了索引的数据结构。 下图就是 Innodb 里的 B+ 树:\n![图片](3-29 B Tree.assets/dd076212a7637b9032c97a615c39dcd7.png)\n但是 Innodb 使用的 B+ 树有一些特别的点，比如: Innodb 根据索引类型不同，分为聚簇和二级索引。他们区别在于: 因为表的数据都是存放在聚簇索引的叶子节点里所以InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。\n下面详细稍微讲一下聚簇索引和二级索引\n聚簇索引和二级索引 另外，索引又可以分成聚集索引和非聚集索引(二级索引)，它们区别就在于叶子节点存放的是什么数据: 聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点; 二级索引的叶子节点存放的是主键值，而不是实际数据， 因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。 InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引: 如果有主键，默认会使用主键作为聚簇索引的索引键; 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键;在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键; -张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引(非聚簇索引/辅助索引)，它也是利用了 B+树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据， 级索引的 B+树如下图，数据部分为主键值:\n![Image](3-29 B Tree.assets/640.webp)\n因此，如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+树就能找到数据。\n非聚簇索引（mysql中的，和InnoDB中的概念不同） 这里介绍的非聚簇索引是指MyISM引擎中的非聚簇索引，不是InnoDB引擎中的非聚簇索引（二级索引结构也为非聚簇索引结构）。\n（1）非聚簇索引是一种索引方式，MyISM采用的是非聚簇索引，其索引文件结构为B+Tree结构。索引文件和数据文件是分离的。索引文件存储B+Tree结构，数据文件存储表中的数据行。\n（2）索引文件是按照索引键值和表数据内存地址构建的B+Tree，其结构的叶子节点存储了索引列的值和指向数据文件中记录的物理位置（通常磁盘地址）的指针。\n（3）每个索引对应一个B+Tree结构的索引文件，索引文件是独立的。通过辅助索引检索时，无需访问主键索引树。\n（4）执行查询时，会利用非聚簇索引中的索引列值对B+Tree从根节点逐层查找，找到叶子节点。从叶子节点中获取记录的物理位置（磁盘地址）找到数据文件，从数据文件中获取响应的记录。当索引覆盖扫描时，可以直接从索引文件中返回这些值，无需再访问数据文件。\n![在这里插入图片描述](3-29 B Tree.assets/c3c42843bb7a4ca7883e021f3a9491a8.png)\n","permalink":"http://localhost:1313/posts/3-29-b-tree/","summary":"\u003ch1 id=\"b-tree-and-b-tree\"\u003eB tree and B+ tree\u003c/h1\u003e\n\u003ch2 id=\"b-tree\"\u003eB tree\u003c/h2\u003e\n\u003ch3 id=\"引入\"\u003e引入\u003c/h3\u003e\n\u003cp\u003eB 树（B-tree）是一种自平衡的搜索树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B 树的每个节点可以拥有两个以上的子节点，因此 B 树是一种多路搜索树。\u003c/p\u003e","title":"B tree and B+ tree"},{"content":"ElasticSearch 核心概念 文档（Document）：ES 存储的基本单元，类似一条 JSON 数据 索引（Index）：存储一类文档的集合，类似于数据库中的表。 字段（Field）：文档中的每个键值对。 倒排索引：ES 的底层结构，用于加速全文搜索。 分片（Shard）与副本（Replica）：ES 支持分布式存储和查询，分片用于水平扩展。 底层逻辑 索引 在介绍倒排索引之前，我们先来了解一下正排索引和全文检索。\n全文检索 定义 全文检索是指系统不是按精确关键词匹配，而是理解文本内容的语言特性，实现模糊匹配、分词、排序、短语识别等操作的搜索方式。\n例子 你在淘宝搜索框输入「苹果手机」，结果可能包括：\n标题是「iPhone 15」 描述含有「苹果新品」 同义词或错拼「pingguo」 全文检索VS模糊匹配 全文检索：\n​\t分词后匹配多个词项。\n​\t关键词需要准确\n​\t技术：分词器、倒排索引、BM25打分\n模糊匹配:\n​\t近似匹配：如拼写错误\n​\t技术:Levenshtein编辑距离算法\n正排索引 即顺序索引，按照文档ID存储文档的所有内容。\n因此每次进行全文索引的时候需要对每个文档的所有内容进行扫描。\n查询需要O(n)的时间复杂度，对文章扫描更加耗时，因此正排索引进行全文检索的效率尤其低下。\n于是出现了倒排索引\n倒排索引 概念 接下来我们详细介绍倒排索引\n我们需要根据文本的词来找到相应的文档，自然而然的我们可以想到预处理的模式，设置一个映射结构，即由词项来映射文本id\n实例 假设有以下 3 篇文档：\n文档ID 内容 1 苹果 手机 2 苹果 平板 3 小米 手机 构建倒排索引后：\n1iniCopyEdit\u0026#34;苹果\u0026#34; =\u0026gt; [1, 2] 2\u0026#34;手机\u0026#34; =\u0026gt; [1, 3] 3\u0026#34;平板\u0026#34; =\u0026gt; [2] 4\u0026#34;小米\u0026#34; =\u0026gt; [3] 倒排索引的构建 假设数据\n文档集如下：\n文档 ID 文本内容 1 \u0026ldquo;I love apple phone\u0026rdquo; 2 \u0026ldquo;Apple releases new phone\u0026rdquo; 3 \u0026ldquo;I like banana\u0026rdquo; 文本清洗和规范化（Normalization）\n统一格式，便于处理：\n全部小写：大写 → 小写 去除标点：,、. 等去除 去除停用词（如：is, the, a） 可选：词干提取（stemming）或词形还原（lemmatization） 处理结果\n文档 ID 处理后文本 1 i love apple phone 2 apple releases new phone 3 i like banana 分词（Tokenization）\n将文本拆成一个个词项（token）：\n文档 ID Token List 1 [i, love, apple, phone] 2 [apple, releases, new, phone] 3 [i, like, banana] 记录词项在文档中的位置和频率（Posting）\n构建 Posting 结构，一般如下：\ngoCopyEdittype Posting struct {\rDocID int\rPositions []int // 单词在文档中的位置\rFrequency int // 出现次数\r} 如 \u0026quot;apple\u0026quot;：\n出现在文档 1 的位置 3（从 0 开始） 出现在文档 2 的位置 0 构建倒排表（Inverted Index）\n将所有文档中出现的 token 按词项归类，记录在哪些文档中出现，并附带位置信息。\n构建出的倒排索引如下：\n1iniCopyEdit\u0026#34;i\u0026#34; =\u0026gt; [ {DocID:1, Pos:[0]}, {DocID:3, Pos:[0]} ] 2\u0026#34;love\u0026#34; =\u0026gt; [ {DocID:1, Pos:[1]} ] 3\u0026#34;apple\u0026#34; =\u0026gt; [ {DocID:1, Pos:[2]}, {DocID:2, Pos:[0]} ] 4\u0026#34;phone\u0026#34; =\u0026gt; [ {DocID:1, Pos:[3]}, {DocID:2, Pos:[3]} ] 5\u0026#34;releases\u0026#34; =\u0026gt; [ {DocID:2, Pos:[1]} ] 6\u0026#34;new\u0026#34; =\u0026gt; [ {DocID:2, Pos:[2]} ] 7\u0026#34;like\u0026#34; =\u0026gt; [ {DocID:3, Pos:[1]} ] 8\u0026#34;banana\u0026#34; =\u0026gt; [ {DocID:3, Pos:[2]} ] 这就是完整的倒排索引。\n压缩与优化（Lucene/ES 实现细节）\n真实系统中，为了节省空间和提高查询效率，还会进行：\n技术名 作用 跳跃表（skip list） 快速跳过不相关文档块，提升查找效率 位图压缩（Roaring bitmap） 压缩大规模 DocID 集合，提高布尔查询速度 前缀压缩（Front coding） 压缩词典中相似词项（如 apple, apples） 段合并（Segment Merge） 多个小段合并减少碎片，提升读取性能 ","permalink":"http://localhost:1313/posts/elasticsearch/","summary":"\u003ch2 id=\"elasticsearch\"\u003eElasticSearch\u003c/h2\u003e\n\u003ch2 id=\"核心概念\"\u003e核心概念\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e文档（Document）\u003c/strong\u003e：ES 存储的基本单元，类似一条 JSON 数据\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e索引（Index）\u003c/strong\u003e：存储一类文档的集合，类似于数据库中的表。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e字段（Field）\u003c/strong\u003e：文档中的每个键值对。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e倒排索引\u003c/strong\u003e：ES 的底层结构，用于加速全文搜索。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e分片（Shard）与副本（Replica）\u003c/strong\u003e：ES 支持分布式存储和查询，分片用于水平扩展。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"底层逻辑\"\u003e底层逻辑\u003c/h3\u003e\n\u003ch4 id=\"索引\"\u003e索引\u003c/h4\u003e\n\u003cp\u003e在介绍\u003cstrong\u003e倒排索引\u003c/strong\u003e之前，我们先来了解一下\u003cstrong\u003e正排索引\u003c/strong\u003e和\u003cstrong\u003e全文检索\u003c/strong\u003e。\u003c/p\u003e","title":""},{"content":"","permalink":"http://localhost:1313/posts/microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%A7%E7%94%9F/%E5%88%9D%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1/","summary":"","title":""},{"content":"","permalink":"http://localhost:1313/posts/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","summary":"","title":""},{"content":"","permalink":"http://localhost:1313/about/","summary":"about","title":"关于"}]